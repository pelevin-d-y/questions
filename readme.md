ответы на популярные вопросы:
https://habr.com/post/351874/

### Методы для повышения производительности при создании или обслуживании сайта
**https://habr.com/company/badoo/blog/320558/**
lighthouse
Прогрессивное улучшение (https://htmlacademy.ru/blog/7-progressive-enhancement)
react, vue (next, nuxt)

### SEO
Поисковая оптимизация сайтов представляет собой деятельность, которая необходима для увеличения позиций сайта по итогам выдачи результатов поисковыми машинами по определенным запросам.

### Делегирование событий.
Всплытие событий позволяет реализовать один из самых важных приёмов разработки – делегирование.

Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

**Плюсы**

1. Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.
2. Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
3. Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.

**Минусы**

1. Во-первых, событие должно всплывать. Нельзя, чтобы какой-то промежуточный обработчик вызвал event.stopPropagation() до того, как событие доплывёт до  нужного элемента.
2. Во-вторых, делегирование создает дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.

### Как работает this в JS

Значение this обычно определено контекстом выполняемой функции. Под контекстом подразумеваетс то, как вызывается функция.

В глобальном поле видимости, this относится к глобальному объекту.

При использовании new, this привязывает к новому созданному объекту.

Мы можем явно указывать значения this, с помощью call(), bind() и apply().

Стрелочные функции не привязывают this — заместо этого this связывается лексически, основываясь на оригинальном контексте).

### Прототипное наследование.

Если один объект имеет специальную ссылку `__proto__` на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте `__proto__`.

В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства `__proto__`.
При установке свойства `rabbit.__proto__ = animal` говорят, что объект animal будет «прототипом» rabbit.
При чтении свойства из объекта, если его в нём нет, оно ищется в `__proto__`. Прототип задействуется только при чтении свойства. Операции присвоения `obj.prop =` или удаления `delete obj.prop` совершаются всегда над самим объектом obj.
Несколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку, когда один объект ссылается на другой при помощи `__proto__`, тот ссылается на третий, и так далее.

### AMD и CommonJS
